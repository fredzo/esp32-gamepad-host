/*
 * Copyright (C) 2017 BlueKitchen GmbH
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holders nor the names of
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 * 4. Any redistribution, use, or modification is done solely for
 *    personal benefit and not for any commercial purpose or for
 *    monetary gain.
 *
 * THIS SOFTWARE IS PROVIDED BY BLUEKITCHEN GMBH AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL BLUEKITCHEN
 * GMBH OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
 * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * Please inquire about commercial licensing options at 
 * contact@bluekitchen-gmbh.com
 *
 */

/*
 * hid_host_demo.c
 */

/* EXAMPLE_START(hid_host_demo): HID Host Classic
 *
 * @text This example implements a HID Host. For now, it connects to a fixed device.
 * It will connect in Report protocol mode if this mode is supported by the HID Device,
 * otherwise it will fall back to BOOT protocol mode. 
 */

#include <inttypes.h>
#include <stdio.h>

#include "config.h"

#include "btstack_config.h"
#include "btstack.h"
#include <gap_inquiry.h>
#include <hci_dump.h>

extern void btstack_init();

/*************************************************************************************************/

#define ENABLE_LOG_DEBUG
#define L2CAP_CHANNEL_MTU 128

#define MAX_ATTRIBUTE_VALUE_SIZE 300

#define CLASS_OF_DEVICE_GAMEPAD_START  0x002500
#define CLASS_OF_DEVICE_GAMEPAD_END    0x0025FF


// MBP 2016 static const char * remote_addr_string = "F4-0F-24-3B-1B-E1";
// iMpulse static const char * remote_addr_string = "64:6E:6C:C1:AA:B5";
// Logitec 
//static const char * remote_addr_string = "1F-97-19-05-06-07";

static bd_addr_t remote_addr;

static btstack_packet_callback_registration_t hci_event_callback_registration;


// SDP
static uint8_t hid_descriptor_storage[MAX_ATTRIBUTE_VALUE_SIZE];

// Last packet
static uint8_t last_packet[128];

// App
static enum {
    APP_INIT,
    APP_IDLE,
    APP_CONNECTING,
    APP_CONNECTED
} app_state = APP_INIT;

static uint16_t hid_host_cid = 0;
static bool     hid_host_descriptor_available = false;
static hid_protocol_mode_t hid_host_report_mode = HID_PROTOCOL_MODE_REPORT_WITH_FALLBACK_TO_BOOT;

////////////////// Gap Inquiry


#define MAX_DEVICES 20
enum DEVICE_STATE { REMOTE_NAME_REQUEST, REMOTE_NAME_INQUIRED, REMOTE_NAME_FETCHED };
struct device {
    bd_addr_t          address;
    uint8_t            pageScanRepetitionMode;
    uint16_t           clockOffset;
    enum DEVICE_STATE  state; 
};

#define INQUIRY_INTERVAL 5
struct device devices[MAX_DEVICES];
int deviceCount = 0;


static int getDeviceIndexForAddress( bd_addr_t addr){
    int j;
    for (j=0; j< deviceCount; j++){
        if (bd_addr_cmp(addr, devices[j].address) == 0){
            return j;
        }
    }
    return -1;
}

static void start_scan(void){
    printf("Starting inquiry scan..\n");
    uint8_t result = gap_inquiry_start(INQUIRY_INTERVAL);
    if(result != ERROR_CODE_SUCCESS) {
        printf("Inquiry failed, status 0x%02x\n", result);
    }
}

static int has_more_remote_name_requests(void){
    int i;
    for (i=0;i<deviceCount;i++) {
        if (devices[i].state == REMOTE_NAME_REQUEST) return 1;
    }
    return 0;
}

static void do_next_remote_name_request(void){
    int i;
    for (i=0;i<deviceCount;i++) {
        // remote name request
        if (devices[i].state == REMOTE_NAME_REQUEST){
            devices[i].state = REMOTE_NAME_INQUIRED;
            printf("Get remote name of %s...\n", bd_addr_to_str(devices[i].address));
            gap_remote_name_request( devices[i].address, devices[i].pageScanRepetitionMode,  devices[i].clockOffset | 0x8000);
            return;
        }
    }
}

static void continue_remote_names(void){
    if (has_more_remote_name_requests()){
        do_next_remote_name_request();
        return;
    }
    start_scan();
}

//////////////////

/* @section Main application configuration
 *
 * @text In the application configuration, L2CAP and HID host are initialized, and the link policies 
 * are set to allow sniff mode and role change. 
 */

/* LISTING_START(PanuSetup): Panu setup */
static void packet_handler (uint8_t packet_type, uint16_t channel, uint8_t *packet, uint16_t size);

static void hid_host_setup(void){

    // Initialize L2CAP
    l2cap_init();

    // Initialize HID Host
    hid_host_init(hid_descriptor_storage, sizeof(hid_descriptor_storage));
    hid_host_register_packet_handler(packet_handler);

    // Allow sniff mode requests by HID device and support role switch
    gap_set_default_link_policy_settings(LM_LINK_POLICY_ENABLE_SNIFF_MODE | LM_LINK_POLICY_ENABLE_ROLE_SWITCH);
    /*gap_set_security_level(LEVEL_0);
    gap_set_security_mode(GAP_SECURITY_MODE_2);
    gap_ssp_set_enable(false);*/

    // try to become master on incoming connections
    hci_set_master_slave_policy(HCI_ROLE_MASTER);

    // register for HCI events
    hci_event_callback_registration.callback = &packet_handler;
    hci_add_event_handler(&hci_event_callback_registration);

    //hci_dump_init(hci_dump_embedded_stdout_get_instance());

    // Disable stdout buffering
    setvbuf(stdin, NULL, _IONBF, 0);
}
/* LISTING_END */

const uint8_t rumble[] = {0xc0, 0x20, 
0xf3, // Update // 0c
0x02, 0x00,  //020 f7
0xFF, // Left
0xFF, // Right
0xFF, // Red
0x00, // Green
0xFF, // Blue
0xFF, 0xFF, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x43, 0x43, 0x00, 0x4d, 0x85, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

const uint8_t rumbleOff[] = {0xc0, 0x20, 
0xf3, // Update
0x02, 0x00, 
0x00, // Left
0x00, // Right
0x00, // Red
0xFF, // Green
0x00, // Blue
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x43, 0x43, 0x00, 0x4d, 0x85, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

uint16_t rumbleBtChanel;
bool shouldRumble = false;

/*
 * @section Packet Handler
 * 
 * @text The packet handler responds to various HID events.
 */

/* LISTING_START(packetHandler): Packet Handler */
static void packet_handler (uint8_t packet_type, uint16_t channel, uint8_t *packet, uint16_t size)
{
    /* LISTING_PAUSE */
    UNUSED(channel);
    UNUSED(size);

    if (packet_type != HCI_EVENT_PACKET) return;

    uint8_t   event;
    bd_addr_t event_addr;
    uint8_t   status;

    int i;
    int index;

    uint8_t packetSize;
    const uint8_t * report;
    uint32_t classOfDevice;
    uint8_t pin[6];

    event = hci_event_packet_get_type(packet);

    /* LISTING_RESUME */
    if (app_state == APP_INIT) {
        /* @text In INIT, an inquiry  scan is started, and the application transits to 
         * ACTIVE state.
         */
        switch(event){
            case BTSTACK_EVENT_STATE:
                if (btstack_event_state_get_state(packet) == HCI_STATE_WORKING){
                    start_scan();
                    app_state = APP_IDLE;
                }
                break;
            default:
                break;
        }
    }
    else
    {
        /* @text In ACTIVE, the following events are processed:
         *  - GAP Inquiry result event: BTstack provides a unified inquiry result that contain
         *    Class of Device (CoD), page scan mode, clock offset. RSSI and name (from EIR) are optional.
         *  - Inquiry complete event: the remote name is requested for devices without a fetched 
         *    name. The state of a remote name can be one of the following: 
         *    REMOTE_NAME_REQUEST, REMOTE_NAME_INQUIRED, or REMOTE_NAME_FETCHED.
         *  - Remote name request complete event: the remote name is stored in the table and the 
         *    state is updated to REMOTE_NAME_FETCHED. The query of remote names is continued.
         */
            
        //printf("HCI_EVENT_PACKET: 0x%02x\n", hci_event_packet_get_type(packet));

        switch (event) {            
            case GAP_EVENT_INQUIRY_RESULT:
                if (deviceCount >= MAX_DEVICES) break;  // already full
                gap_event_inquiry_result_get_bd_addr(packet, event_addr);
                index = getDeviceIndexForAddress(event_addr);
                if (index >= 0) break;   // already in our list

                memcpy(devices[deviceCount].address, event_addr, 6);
                devices[deviceCount].pageScanRepetitionMode = gap_event_inquiry_result_get_page_scan_repetition_mode(packet);
                devices[deviceCount].clockOffset = gap_event_inquiry_result_get_clock_offset(packet);
                // print info
                classOfDevice = gap_event_inquiry_result_get_class_of_device(packet);
                printf("Device found: %s ",  bd_addr_to_str(event_addr));
                printf("with COD: 0x%06x, ", (unsigned int) classOfDevice);
                printf("pageScan %d, ",      devices[deviceCount].pageScanRepetitionMode);
                printf("clock offset 0x%04x",devices[deviceCount].clockOffset);
                if (gap_event_inquiry_result_get_rssi_available(packet)){
                    printf(", rssi %d dBm", (int8_t) gap_event_inquiry_result_get_rssi(packet));
                }
                if (gap_event_inquiry_result_get_name_available(packet)){
                    char name_buffer[240];
                    int name_len = gap_event_inquiry_result_get_name_len(packet);
                    memcpy(name_buffer, gap_event_inquiry_result_get_name(packet), name_len);
                    name_buffer[name_len] = 0;
                    printf(", name '%s'", name_buffer);
                    devices[deviceCount].state = REMOTE_NAME_FETCHED;;
                } else {
                    devices[deviceCount].state = REMOTE_NAME_REQUEST;
                }
                printf("\n");
                deviceCount++;
                if(classOfDevice >= CLASS_OF_DEVICE_GAMEPAD_START && classOfDevice <= CLASS_OF_DEVICE_GAMEPAD_END)
                {
                    // Connect to device
                    printf("Connect to device.\n");

                    status = hid_host_connect(event_addr, hid_host_report_mode, &hid_host_cid);
                    if (status == ERROR_CODE_SUCCESS) {
                        app_state = APP_CONNECTING;
                    } else {
                        printf("Host connection failed, status 0x%02x\n", status);
                    }
                }
                break;

            case GAP_EVENT_INQUIRY_COMPLETE:
                for (i=0;i<deviceCount;i++) {
                    // retry remote name request
                    if (devices[i].state == REMOTE_NAME_INQUIRED)
                        devices[i].state = REMOTE_NAME_REQUEST;
                }
                continue_remote_names();
                break;

            case HCI_EVENT_REMOTE_NAME_REQUEST_COMPLETE:
                reverse_bd_addr(&packet[3], event_addr);
                index = getDeviceIndexForAddress(event_addr);
                if (index >= 0) {
                    if (packet[2] == 0) {
                        printf("Name: '%s'\n", &packet[9]);
                        devices[index].state = REMOTE_NAME_FETCHED;
                    } else {
                        printf("Failed to get name: page timeout\n");
                    }
                }
                continue_remote_names();
                break;

            /* @text When BTSTACK_EVENT_STATE with state HCI_STATE_WORKING
                * is received and the example is started in client mode, the remote SDP HID query is started.
                */
            /*case BTSTACK_EVENT_STATE:
                if ((btstack_event_state_get_state(packet) == HCI_STATE_WORKING) && (app_state == APP_IDLE))
                {
                    printf("Connect to device.\n");
                    status = hid_host_connect(remote_addr, hid_host_report_mode, &hid_host_cid);
                    if (status == ERROR_CODE_SUCCESS) {
                        app_state = APP_CONNECTING;
                    } else {
                        printf("Connection failed, status 0x%02x\n", status);
                    }
                }
                break;*/


            /* LISTING_PAUSE */
            case HCI_EVENT_PIN_CODE_REQUEST:
                // inform about pin code request
                printf("Pin code request - using '0000'\n");
                hci_event_pin_code_request_get_bd_addr(packet, event_addr);
                /*pin[0] = event_addr[5];
                pin[1] = event_addr[4];
                pin[2] = event_addr[3];
                pin[3] = event_addr[2];
                pin[4] = event_addr[1];
                pin[5] = event_addr[0];
                gap_pin_code_response_binary(event_addr, pin, 6);*/
                gap_pin_code_response(event_addr, "0000");
                break;

            case HCI_EVENT_USER_CONFIRMATION_REQUEST:
                // inform about user confirmation request
                printf("SSP User Confirmation Request with numeric value '%"PRIu32"'\n", little_endian_read_32(packet, 8));
                printf("SSP User Confirmation Auto accept\n");
                break;

            /* LISTING_RESUME */
            case HCI_EVENT_HID_META:
                switch (hci_event_hid_meta_get_subevent_code(packet)){

                    case HID_SUBEVENT_INCOMING_CONNECTION:
                        // There is an incoming connection: we can accept it or decline it.
                        // The hid_host_report_mode in the hid_host_accept_connection function 
                        // allows the application to request a protocol mode. 
                        // For available protocol modes, see hid_protocol_mode_t in btstack_hid.h file. 
                        hid_host_accept_connection(hid_subevent_incoming_connection_get_hid_cid(packet), hid_host_report_mode);
                        break;
                    
                    case HID_SUBEVENT_CONNECTION_OPENED:
                        // The status field of this event indicates if the control and interrupt
                        // connections were opened successfully.
                        status = hid_subevent_connection_opened_get_status(packet);
                        if (status != ERROR_CODE_SUCCESS) {
                            printf("Connection failed, status 0x%02x\n", status);
                            app_state = APP_IDLE;
                            hid_host_cid = 0;
                            return;
                        }
                        app_state = APP_CONNECTED;
                        hid_host_descriptor_available = false;
                        hid_host_cid = hid_subevent_connection_opened_get_hid_cid(packet);
                        printf("HID Host connected.\n");
                        // Send get report for extended report
                        hid_host_send_get_report(hid_host_cid,HID_REPORT_TYPE_FEATURE,0x02);
                        break;

                    case HID_SUBEVENT_DESCRIPTOR_AVAILABLE:
                        // This event will follows HID_SUBEVENT_CONNECTION_OPENED event. 
                        // For incoming connections, i.e. HID Device initiating the connection,
                        // the HID_SUBEVENT_DESCRIPTOR_AVAILABLE is delayed, and some HID  
                        // reports may be received via HID_SUBEVENT_REPORT event. It is up to 
                        // the application if these reports should be buffered or ignored until 
                        // the HID descriptor is available.
                        status = hid_subevent_descriptor_available_get_status(packet);
                        if (status == ERROR_CODE_SUCCESS){
                            hid_host_descriptor_available = true;
                            printf("HID Descriptor available, please start typing.\n");
                        } else {
                            printf("Cannot handle input report, HID Descriptor is not available, status 0x%02x\n", status);
                        }
                        break;

                    case HID_SUBEVENT_REPORT:
                        // Handle input report.
                        //if (hid_host_descriptor_available){
                        //    hid_host_handle_interrupt_report(hid_subevent_report_get_report(packet), hid_subevent_report_get_report_len(packet));
                        //} else {
                            packetSize = hid_subevent_report_get_report_len(packet)+1;
                            report = hid_subevent_report_get_report(packet);
                            if(packetSize < 128 && (memcmp(last_packet,report,10)!=0))
                            {
                                //printf("Mecmp = %d.\n",memcmp(last_packet,report,packetSize));
                                //printf_hexdump(last_packet,packetSize);
                                memcpy(last_packet,report,packetSize);
                                printf_hexdump(report,42);
                                /*if(report[8]>0)
                                {
                                    printf("Will Rumble.\n");
                                    rumbleBtChanel = channel;
                                    shouldRumble = true;
                                }*/
                            }
                        //}
                        break;

                    case HID_SUBEVENT_SET_PROTOCOL_RESPONSE:
                        // For incoming connections, the library will set the protocol mode of the
                        // HID Device as requested in the call to hid_host_accept_connection. The event 
                        // reports the result. For connections initiated by calling hid_host_connect, 
                        // this event will occur only if the established report mode is boot mode.
                        status = hid_subevent_set_protocol_response_get_handshake_status(packet);
                        if (status != HID_HANDSHAKE_PARAM_TYPE_SUCCESSFUL){
                            printf("Error set protocol, status 0x%02x\n", status);
                            break;
                        }
                        switch ((hid_protocol_mode_t)hid_subevent_set_protocol_response_get_protocol_mode(packet)){
                            case HID_PROTOCOL_MODE_BOOT:
                                printf("Protocol mode set: BOOT.\n");
                                break;  
                            case HID_PROTOCOL_MODE_REPORT:
                                printf("Protocol mode set: REPORT.\n");
                                break;
                            default:
                                printf("Unknown protocol mode.\n");
                                break; 
                        }
                        break;

                    case HID_SUBEVENT_CONNECTION_CLOSED:
                        // The connection was closed.
                        hid_host_cid = 0;
                        hid_host_descriptor_available = false;
                        printf("HID Host disconnected.\n");
                        break;
                    
                    default:
                        break;
                }
                break;
            default:
                break;
        }
    }
}
/* LISTING_END */

bool rumbleState = false;
void maybeRumble()
{
    if(shouldRumble)
    {
        shouldRumble = false;
        rumbleState = !rumbleState;
        printf("Before Rumble with state %d.\n",rumbleState);
        hid_host_send_report(rumbleBtChanel,0x11,rumbleState ? rumble : rumbleOff,(sizeof(rumble)-1));
        printf("After Rumble !\n");
    }
}

static const char remote_addr_string[] = "1F-97-19-05-06-07";
//static const char remote_addr_string[] = "CC-9E-00-C9-FC-F1";

int btstack_main_new(int argc, const char * argv[]){

    (void)argc;
    (void)argv;

    // Configure BTstack
    btstack_init();

    // enabled EIR
    hci_set_inquiry_mode(INQUIRY_MODE_RSSI_AND_EIR);

    hid_host_setup();

    // parse human readable Bluetooth address
    sscanf_bd_addr(remote_addr_string, remote_addr);

    // Turn on the device 
    hci_power_control(HCI_POWER_ON);

    return 0;
}

/* EXAMPLE_END */
